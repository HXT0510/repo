import numpy as np# 导入NumPy库

class KalmanFilter(object):# 初始化
    def __init__(self, F = None, B = None, H = None, Q = None, R = None, P = None, x0 = None):# 检查必要的系统动态矩阵是否提供

        if(F is None or H is None):# 如果没有，抛出错误
            raise ValueError("Set proper system dynamics.")

        self.n = F.shape[1]# 从F矩阵的列数，获取状态向量的维度
        self.m = H.shape[1]# 从H矩阵的列数，获取测量向量的维度

        self.F = F# 设置状态转移矩阵
        self.H = H# 设置观测矩阵
        self.B = 0 if B is None else B# 如果没有提供控制输入矩阵B，则设为0；否则使用提供的值
        self.Q = np.eye(self.n) if Q is None else Q# 如果没有提供过程噪声协方差矩阵Q，则设为n×n的单位矩阵；否则使用提供的值
        self.R = np.eye(self.n) if R is None else R# 如果没有提供测量噪声协方差矩阵R，则设为n×n的单位矩阵；否则使用提供的值
        self.P = np.eye(self.n) if P is None else P# 如果没有提供估计误差协方差矩阵P，则设为n×n的单位矩阵；否则使用提供的值
        self.x = np.zeros((self.n, 1)) if x0 is None else x0# 如果没有提供初始状态向量x0，则设为n×1的零向量；否则使用提供的值

    def predict(self, u = 0):# 根据当前状态和控制输入预测下一时刻的状态
        self.x = np.dot(self.F, self.x) + np.dot(self.B, u)# 预测状态：x = F*x + B*u
        self.P = np.dot(np.dot(self.F, self.P), self.F.T) + self.Q# 预测误差协方差：P = F*P*F^T + Q
        return self.x# 返回预测的状态

    def update(self, z):# 根据测量值更新状态估计
        y = z - np.dot(self.H, self.x)# 计算测量残差：y = z - H*x
        S = self.R + np.dot(self.H, np.dot(self.P, self.H.T))# 计算残差协方差：S = H*P*H^T + R
        K = np.dot(np.dot(self.P, self.H.T), np.linalg.inv(S))# 计算卡尔曼增益：K = P*H^T*S^(-1)
        self.x = self.x + np.dot(K, y)# 更新状态估计：x = x + K*y
        I = np.eye(self.n)# 创建单位矩阵
        self.P = np.dot(np.dot(I - np.dot(K, self.H), self.P), 
        	(I - np.dot(K, self.H)).T) + np.dot(np.dot(K, self.R), K.T)# 更新误差协方差：P = (I - K*H)*P*(I - K*H)^T + K*R*K^T (Joseph形式，数值稳定)

def example():# 展示如何使用卡尔曼滤波器
	dt = 1.0/60# 设置时间间隔，60Hz采样率
	F = np.array([[1, dt, 0], [0, 1, dt], [0, 0, 1]])# 定义状态转移矩阵
	H = np.array([1, 0, 0]).reshape(1, 3)# 定义观测矩阵
	Q = np.array([[0.05, 0.05, 0.0], [0.05, 0.05, 0.0], [0.0, 0.0, 0.0]])# 定义过程噪声协方差矩阵
	R = np.array([0.5]).reshape(1, 1)# 定义测量噪声协方差矩阵

	x = np.linspace(-10, 10, 100)# 生成x坐标：从-10到10的100个点
	measurements = - (x**2 + 2*x - 2)  + np.random.normal(0, 2, 100)# 生成带有噪声的测量数据

	kf = KalmanFilter(F = F, H = H, Q = Q, R = R)# 创建卡尔曼滤波器实例
	predictions = []# 存储预测结果的列表

	for z in measurements:# 对每个测量值进行滤波
		predictions.append(np.dot(H,  kf.predict())[0])# 进行预测并将结果添加到预测列表
		kf.update(z)# 使用测量值更新滤波器

	import matplotlib.pyplot as plt# 导入matplotlib库用于绘图
	plt.plot(range(len(measurements)), measurements, label = 'Measurements')# 绘制测量值曲线
	plt.plot(range(len(predictions)), np.array(predictions), label = 'Kalman Filter Prediction')# 绘制卡尔曼滤波预测曲线
	plt.legend()# 显示图例
	plt.show()# 显示图形

if __name__ == '__main__':
    example()# 如果直接运行此脚本，则执行示例函数